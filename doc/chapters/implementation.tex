\chapter{Implementation}
\section{Front-End}
The front-end of our application has been developed as a traditional web-based interface, utilizing a combination of \textbf{JavaScript}, \textbf{HTML} and \textbf{CSS}. This technology stack enables the creation of a responsive and interactive user interface that can be accessed from any modern web browser without the need for additional installations. The application communicates asynchronously with the back-end server through \textbf{AJAX} (Asynchronous JavaScript and XML) requests, allowing data to be fetched and updated dynamically without requiring full page reloads. This results in a smoother user experience and improved performance, particularly when handling operations such as appointment booking, profile managementand real-time data visualization. The separation of concerns between presentation and logic also enhances the maintainability and scalability of the application.

\section{Front-End Structure}
The \textbf{resources} directory encapsulates the front-end assets and configuration files essential to the operation and presentation of the web application. Its hierarchical organization reflects a separation of concerns, promoting maintainability and modular development.

Static resources such as CSS and JavaScript files reside in the \textbf{static} folder, structured into subdirectories for stylesheets (\textbf{css/}), scripts (\textbf{js/}) and error pages (\texttt{error/}). These support the visual and interactive components of the application.

Dynamic \textbf{HTML} views based on \textbf{Thymeleaf} are located in the \textbf{templates} folder, with dedicated files for both doctors and users. A \textbf{fragments} subfolder contains reusable layout components (e.g., headers, footers, sidebars) to ensure consistency and reusability. Application-level configuration is managed through \texttt{application.properties}.

\subsection{Static}
The \textbf{static} directory collects all static web assets that are delivered to the client without server-side processing. These assets are organized into three primary subfolders: \texttt{css/}, \texttt{js/}, and \texttt{error/}, each serving a distinct role in the client-side rendering process.

The \textbf{css} folder contains a series of modular stylesheets dedicated to specific views or components. These include both general-purpose files (e.g. \texttt{base.css}, \texttt{main.css}, \texttt{form.css}) and context-specific styles (e.g. \texttt{doctor-dashboard.css}, \texttt{user-profile.css}), which define the visual identity and layout of user and doctor interfaces.

The \textbf{js} folder hosts JavaScript files that manage client-side interactions and dynamic behavior. Each script is associated with a specific view or functionality—for instance, \texttt{login.js} handles authentication interactions, while \texttt{slot-calendar.js} governs dynamic calendar updates for appointment scheduling.

The \textbf{error} folder includes static HTML pages for standard HTTP error responses (400, 404, 500), ensuring that users receive consistent and informative feedback in case of failure scenarios.

This structure promotes modularity and clarity, allowing for straightforward maintenance and scalability of front-end assets.

\subsection{Templates}
The \texttt{templates} directory constitutes a fundamental component within the presentation layer of the web application, as it houses the markup resources responsible for rendering the user interface. This directory is hierarchically organized into subfolders, each reflecting a specific functional domain or interaction paradigm with which the user engages. The HTML documents contained therein are primarily structured using Thymeleaf, a server-side template engine designed for Java-based web environments.

Thymeleaf facilitates the synthesis of dynamic HTML views on the server side, enabling the embedding of context-sensitive data—such as session attributes, query outputsand user-submitted form content—directly into the markup prior to delivery to the client. This server-side rendering paradigm promotes a high degree of interactivity and allows for the generation of customized and context-aware web pages, thereby improving the overall responsiveness and user-centricity of the application interface.

\section{Back-End}
The back-end is implemented using \textbf{Java} due to its robustness, platform independenceand strong ecosystem. Java offers a well-established set of libraries and frameworks that support rapid development of secure, scalableand maintainable web applications. Its object-oriented nature encourages clean architecture and modular design, which are essential for complex systems like healthcare platforms. Additionally, Java's widespread use in enterprise environments ensures long-term support and community-driven innovation, making it a reliable choice for production-grade applications.

\subsection{Spring Boot}
As the core of our application, we adopted the \textbf{Spring Boot} framework, which has significantly streamlined both the development and deployment processes. One of the primary advantages of Spring Boot lies in its built-in support for an embedded \textbf{Tomcat} server, allowing the creation of a fully functional web application without requiring external configuration. This design choice has enhanced our ability to construct responsive and maintainable RESTful APIs. 

In addition, to support our data management needs, we integrated \textbf{Spring Data Neo4j} and \textbf{Spring Data MongoDB}. The former facilitates interaction with the \textbf{Neo4j graph database} through a consistent repository-based abstraction, ideal for managing highly interconnected medical data such as relationships between doctors and patients. The latter offers seamless integration with \textbf{MongoDB}, \textbf{a document-oriented NoSQL database}, while preserving the flexibility and idiomatic programming style of the broader Spring ecosystem. Collectively, these technologies have provided a robust, scalable and modular architecture well-suited to the requirements of our application. 

\section{Back-End Structure}
The application follows the layered architecture presented during lectures, organizing the codebase into clearly defined packages to promote modularity and separation of concerns. 

\subsection{\texttt{package it.unipi.healthhub.config}}
The \textbf{Config} package usually contains configuration classes. In our case, we have only one class. 

The \texttt{FilterConfig} class defines the registration of custom servlet filters used to manage access control within the application. Annotated with \texttt{@Configuration}, it registers filters via \texttt{FilterRegistrationBean}, associating each filter with specific URL patterns. 

In detail:
\begin{itemize}
	\item \texttt{DoctorDashboardAuthFilter}: restricts access to \texttt{/doctor/dashboard/*};
	\item \texttt{PatientDashboardFilter}: applied to \texttt{/user/*};
	\item \texttt{PatientApiFilter}: secures \texttt{/api/user/*};
	\item \texttt{DoctorApiFilter}: secures \texttt{/api/doctor/*};
	\item \texttt{LoginFilter}: manages access to the login page at \texttt{/login}.
\end{itemize}

\subsection{\texttt{package it.unipi.healthhub.controller}}
The \texttt{Controller} package manages API endpoint mappings and web page controllers for the core sections of the application, including the homepage, login, registrationand doctor dashboard. All classes in this package follow the Spring MVC (Model-View-Controller) framework, ensuring a clean separation of concerns between business logic, HTTP request handlingand view rendering.

More spefically:
\begin{itemize}
	\item The \texttt{AuthController} handles authentication and registration processes for both patients (users) and doctors. Its responsibilities include rendering login, registrationand password recovery views; managing user sessions; creating new user accounts; and processing password reset requests. Utility classes such as \texttt{ControllerUtil} and \texttt{HashUtil} are employed to promote modularity and code reuse.
	\item The \texttt{DoctorController} manages requests related to viewing a doctor’s public profile. It retrieves the corresponding data via the \texttt{DoctorService} and injects it into the model for view rendering.
	\item The \texttt{DoctorDashboardController} supports navigation within the doctor's dashboard by mapping each HTTP GET request to a specific section such as appointments, profile, reviews, templatesand weekly schedule. It retrieves the authenticated doctor's data from the session and delegates business logic to the \texttt{DoctorService}.
	\item The \texttt{HomeController} handles requests to the root endpoints (\texttt{/}, \texttt{/index}) and to the \texttt{/search} page. Each method ensures that session-specific data is consistently added to the model using \texttt{ControllerUtil} before returning the appropriate view.
	\item The \texttt{UserController} manages authenticated user interactions through endpoints under \texttt{/user}, including profile viewing, appointmentsand favorite doctors. It uses \texttt{ControllerUtil} to populate the model with session-based data. The class adopts a session-aware MVC design aimed at personalized user interaction.
\end{itemize}

\subsection{\texttt{package it.unipi.healthhub.controller.api}}
The \texttt{it.unipi.healthhub.controller.api} package defines a set of RESTful controllers that expose the application's core services via HTTP endpoints. These controllers are designed to return data (typically in JSON format) allowing asynchronous communication with frontend components and third-party systems.

Serving as the API layer of the system architecture, this package supports decoupled access to key resources such as users, doctors, appointmentsand reviews. It complements the standard MVC controllers by enabling machine-oriented interactions, in alignment with modern web application practices.

\subsubsection{DoctorAPI}
The \texttt{DoctorAPI} class defines a RESTful web interface to manage and interact with doctor-related resources within the \textit{HealthHub} system. It is annotated with \texttt{@RestController} and is mapped to the base path \texttt{/api/doctors}. Below is a summary of the main endpoints:

\begin{itemize}
	\item \texttt{GET /api/doctors} \\
	Returns a list of all registered doctors.
	
	\item \texttt{GET /api/doctors/\{id\}} \\
	Retrieves a specific doctor by their unique identifier.
	
	\item \texttt{POST /api/doctors} \\
	Creates a new doctor resource.
	
	\item \texttt{PUT /api/doctors/\{id\}} \\
	Updates an existing doctor identified by \texttt{id}.
	
	\item \texttt{DELETE /api/doctors/\{id\}} \\
	Deletes the doctor with the specified \texttt{id}.
	
	\item \texttt{GET /api/doctors/\{doctorId\}/services} \\
	Retrieves the list of services offered by the specified doctor.
	
	\item \texttt{GET /api/doctors/\{doctorId\}/appointments} \\
	Returns the list of appointments associated with a doctor.
	
	\item \texttt{POST /api/doctors/\{doctorId\}/appointments} \\
	Books an appointment for the authenticated patient with the given doctor.
	
	\item \texttt{GET /api/doctors/\{doctorId\}/templates} \\
	Retrieves scheduling templates used by the doctor.
	
	\item \texttt{GET /api/doctors/\{doctorId\}/schedules/week?year=\dots\&week=\dots} \\
	Returns the weekly schedule (including prenotable slots) for a doctor, given the ISO week and year.
	
	\item \texttt{GET /api/doctors/\{doctorId\}/endorsements} \\
	Retrieves the total number of endorsements for a doctor and whether the current user has endorsed them.
	
	\item \texttt{POST /api/doctors/\{doctorId\}/endorse} \\
	Allows a logged-in patient to endorse a doctor.
	
	\item \texttt{POST /api/doctors/\{doctorId\}/unendorse} \\
	Removes an existing endorsement made by the patient.
	
	\item \texttt{GET /api/doctors/\{doctorId\}/reviews} \\
	Returns all patient reviews for the specified doctor.
	
	\item \texttt{POST /api/doctors/\{doctorId\}/reviews} \\
	Submits a review for a doctor, provided the patient has had an appointment with them.
	
	\item \texttt{GET /api/doctors/\{doctorId\}/reviews/week/count} \\
	Returns the number of reviews a doctor received during the current ISO week.
\end{itemize}

\subsubsection{PrivateDoctorAPI}
The \texttt{PrivateDoctorAPI} class implements a secure REST interface for authenticated doctors to manage their personal data, appointmentsand analytic insights. Annotated with \texttt{@RestController} and mapped to \texttt{/api/doctor}, it delegates domain logic to \texttt{AppointmentService} and \texttt{DoctorService}, enforcing session‐based access control. Below is a summary of the main endpoints:

\begin{itemize}
	\item \texttt{GET /api/doctor/appointments} \\
	retrieves today's appointments (or for a given date).
	\item \texttt{DELETE /api/doctor/appointments/\{id\}} \\
	deletes an appointment.
	\item \texttt{PUT /api/doctor/address} \\
	updates the doctor's address.
	\item \texttt{PUT /api/doctor/info} \\
	updates the doctor's profile info.
	\item \texttt{POST /api/doctor/phone} \\
	adds a phone number.
	\item \texttt{DELETE /api/doctor/phone/\{index\}} \\
	removes a phone number by a doctor.
	\item \texttt{POST /api/doctor/specialization} \\
	adds a specialization.
	\item \texttt{DELETE /api/doctor/specialization/\{index\}} \\
	removes a specialization.
	\item \texttt{POST /api/doctor/service} \\
	adds a medical service.
	\item \texttt{GET /api/doctor/service} \\
	retrieves all offered services.
	\item \texttt{PUT /api/doctor/service} \\
	updates a medical service.
	\item \texttt{DELETE /api/doctor/service/\{id\}} \\
	deletes a medical service.
	\item \texttt{POST /api/doctor/template} \\
	creates a new availability template.
	\item \texttt{GET /api/doctor/template} \\
	retrieves all availability templates.
	\item \texttt{PUT /api/doctor/template} \\
	updates a template. 
	\item \texttt{DELETE /api/doctor/template/\{id\}} \\
	deletes a template.
	\item \texttt{PUT /api/doctor/template/default} \\
	sets the default availability template.
	\item \texttt{POST /api/doctor/schedule} \\
	creates a weekly schedule.
	\item \texttt{GET /api/doctor/schedule} \\
	retrieves the weekly schedule.
	\item \texttt{PUT /api/doctor/schedule} \\
	updates the weekly schedule.
	\item \texttt{DELETE /api/doctor/schedule} \\
	deletes the weekly schedule.
	\item \texttt{GET /api/doctor/reviews} \\
	retrieves all received reviews.
	\item \texttt{DELETE /api/doctor/review/\{id\}} \\
	deletes a review.
	\item \texttt{PUT /api/doctor/password} \\
	changes the password.
	\item \texttt{GET /api/doctor/stats/visits}\\
	gets number of visits (optionally weekly).
	\item \texttt{GET /api/doctor/stats/earnings}\\
	gets annual earnings.
	\item \texttt{GET /api/doctor/stats/patients} \\
	gets number of new patients per month.
\end{itemize}

\subsubsection{UserAPI}
The \texttt{UserAPI} controller is a RESTful web service component. It provides endpoints for managing user entities within the HealthHub application, leveraging the \texttt{UserService} to perform CRUD (Create, Read, Update, Delete) operations on patients stored in a MongoDB database. The controller follows standard REST conventions, utilizing HTTP verbs to represent actions on resources. 

\begin{itemize}
	\item \texttt{GET /api/users} \\
	Retrieves a list of all users registered in the system.
	
	\item \texttt{GET /api/users/\{id\}} \\
	Fetches a specific user by their unique identifier. Returns HTTP 200 with the user data if found, otherwise HTTP 404.
	
	\item \texttt{POST /api/users} \\
	Creates a new user entity based on the data provided in the request body. Returns the created user.
	
	\item \texttt{PUT /api/users/\{id\}} \\
	Updates an existing user identified by the given ID with new data provided in the request body. Returns HTTP 200 with the updated user if the operation is successful; returns HTTP 404 if the user does not exist.
	
	\item \texttt{DELETE /api/users/\{id\}} \\
	Deletes the user identified by the specified ID. Returns HTTP 204 No Content regardless of whether the user existed, indicating that the request has been processed.
\end{itemize}

\subsubsection{PrivateUserAPI}
The \texttt{PrivateUserAPI} controller is a RESTful web service implemented using the Spring framework in Java, designed to provide secured endpoints for user-specific operations within the HealthHub system. It leverages HTTP sessions to identify the authenticated user (typically a patient) and delegates business logic to the \texttt{UserService}. The controller exposes various endpoints to manage user details, contacts, appointments, doctor recommendationsand password changes, emphasizing privacy and personalization.

\begin{itemize}
	\item \texttt{GET /api/user/details} \\
	Retrieves detailed personal information of the currently authenticated user by extracting the patient ID from the HTTP session. Returns user details or an error message in case of failure.
	
	\item \texttt{PUT /api/user/details} \\
	Updates the personal details of the authenticated user. The new data is supplied in the request body as a \texttt{UserDetailsDTO} object.
	
	\item \texttt{GET /api/user/details/view?id=\{id\}} \\
	Retrieves contact information and demographic data for a user specified by the \texttt{id} query parameter. Additionally, if a doctor is logged in, it returns the number of visits that doctor has conducted with the user.
	
	\item \texttt{GET /api/user/contacts} \\
	Fetches the contact information related to the authenticated user.
	
	\item \texttt{PUT /api/user/contacts} \\
	Updates the contact information of the authenticated user using data provided in the request body as a \texttt{PatientContactsDTO}.
	
	\item \texttt{GET /api/user/appointments/upcoming} \\
	Retrieves a list of upcoming appointments for the authenticated user.
	
	\item \texttt{GET /api/user/appointments/past} \\
	Retrieves a list of past appointments for the authenticated user.
	
	\item \texttt{DELETE /api/user/appointments/\{appointmentId\}} \\
	Cancels the appointment identified by \texttt{appointmentId}. Returns HTTP 200 on success or HTTP 400 if the appointment does not exist.
	
	\item \texttt{GET /api/user/recommendations?limit=\{limit\}} \\
	Returns a list of recommended doctors for the authenticated user, with an optional parameter \texttt{limit} to specify the maximum number of results (default is 3).
	
	\item \texttt{GET /api/user/doctors/reviewed} \\
	Returns a list of doctors that the authenticated user has reviewed.
	
	\item \texttt{GET /api/user/doctors/endorsed} \\
	Returns a list of doctors endorsed by the authenticated user.
	
	\item \texttt{PUT /api/user/password} \\
	Allows the authenticated user to change their password. The current and new passwords are supplied in the request body as a \texttt{PasswordChangeDTO} and are hashed before validation and update.
\end{itemize}

\subsubsection{SearchAPI}
The \texttt{SearchAPI} controller is a RESTful component, responsible for executing search queries specifically targeted at medical doctors within the HealthHub system. This controller integrates data from two distinct data sources: a MongoDB database and a Neo4j graph database. The rationale behind this dual-source approach is to combine traditional document-oriented search results with personalized recommendations derived from graph-based relationships. 

The primary endpoint exposed by this controller is: \texttt{GET /api/search/doctors}.  
This endpoint accepts a mandatory \texttt{query} parameter, representing the search string to be matched against doctor records. Additionally, it accesses the HTTP session to retrieve the identifier of the currently authenticated patient (if available), enabling personalized search refinement. 

Upon receiving a valid query, the controller queries the MongoDB database via \texttt{DoctorService}, returning results as \texttt{DoctorMongoProjection} objects that represent doctor records optimized for search display. If the user is unauthenticated or the patient identifier is absent, the controller returns the top ten doctors from the MongoDB results, sorted by relevance.

For authenticated users, the controller enriches the search outcomes by querying the Neo4j graph database to retrieve personalized recommendations. These recommendations are returned as \texttt{DoctorNeo4jProjection} objects, each associated with a relevance score reflecting the strength of the doctor-patient relationship, such as prior interactions or endorsements. In the absence of Neo4j results, the system falls back to the top MongoDB results.

The integration of results from both sources is achieved by mapping doctor identifiers to Neo4j scores, then augmenting each MongoDB doctor's score accordingly. Doctors without Neo4j matches receive a default negative score to denote lack of personalized relevance. The aggregated list is sorted in descending order by combined scoreand the top ten entries are converted into \texttt{DoctorDTO} objects for API response consistency.

Two private helper methods, \texttt{toDto} and \texttt{toTop10Dto}, support this process by converting raw entities to DTOs and by sorting and limiting the result set. This design ensures that search responses maintain a uniform format, whether or not personalization is applied. Overall, the \texttt{SearchAPI} exemplifies a hybrid search strategy that effectively merges traditional document-based retrieval with graph-driven personalization, leveraging session data to optimize relevance and incorporating fallback mechanisms to ensure robust performance for both authenticated and anonymous users.

\subsection{\texttt{package it.unipi.healthhub.dto}}
The Data Transfer Objects (DTO) directory encapsulates a set of plain Java objects that serve as data carriers between different layers of the HealthHub application, primarily facilitating communication between the service and presentation tiers. These DTO classes are designed to aggregate and structure data relevant to specific business operations or user interactions, decoupling the internal domain model from external API contracts.

\subsection{\texttt{package it.unipi.healthhub.exception}}
The \texttt{it.unipi.healthhub.exception} package defines a set of custom unchecked exceptions, each extending \texttt{RuntimeException}, to represent specific error conditions encountered in the HealthHub application’s domain logic. By encapsulating distinct failure scenarios—such as missing resources or duplicate entries—these exceptions facilitate clear error propagation and centralized handling in higher layers (e.g., controllers or global exception handlers). Moreover, they improve code readability by replacing generic error signals with semantically meaningful types.

\begin{itemize}
	\item \texttt{DoctorNotFoundException}:  
	Thrown when an operation attempts to retrieve or manipulate a doctor entity that does not exist in the system. Constructors allow for default or custom error messagesand for nesting an underlying cause;
	
	\item \texttt{ScheduleAlreadyExistsException}:  
	Raised to indicate an attempt to create a schedule for a doctor in a week for which a schedule is already defined. This prevents conflicting availability entries. As with other exceptions, it supports message customization and cause propagation;
	
	\item \texttt{UserAlreadyExistsException}:  
	Used when a registration or user-creation process detects that a user with the same unique identifier (e.g., email or fiscal code) is already present in the database. This exception enforces uniqueness constraints at the application layer;
	
	\item \texttt{UserNotFoundException}:  
	Thrown when a requested user resource cannot be found, for instance during authentication, profile retrieval, or update operations. Its constructors mirror those of the other exception types, enabling flexible error reporting.
\end{itemize}

\subsection{\texttt{package it.unipi.healthhub.filter}}
The \texttt{it.unipi.healthhub.filter} package provides servlet filters that centralize authentication and authorization logic for both API and web endpoints. These filters intercept incoming HTTP requests, verify session validity and user rolesand either allow processing to continue, redirect to the login page, or return appropriate HTTP error codes upon access violations.

\begin{itemize}
	\item \textbf{DoctorApiFilter}:
	Ensures that requests to \texttt{/api/doctor/*} originate from an authenticated doctor. If no session exists or the session attribute \texttt{role} is not \texttt{"doctor"}, the filter responds with HTTP 403 Forbidden;
	
	\item \textbf{DoctorDashboardAuthFilter}:
	Protects doctor dashboard pages under \texttt{/doctor/dashboard/*}. It verifies the presence of a valid session with \texttt{role = "doctor"}. If validation fails, the user is redirected to the login page;
	
	\item \textbf{LoginFilter}: 
	Prevents authenticated users from re‐accessing the login page. For existing sessions, GET requests to the login URL are redirected to \texttt{/index} (the home page), while POST attempts are rejected with HTTP 403 Forbidden;
	
	\item \textbf{PatientApiFilter}:
	Applies to \texttt{/api/user/*}, allowing read‐only GET requests for all users but restricting state‐changing methods (POST, PUT, DELETE) exclusively to authenticated patients (session attribute \texttt{role = "patient"}). Unauthorized modification attempts yield HTTP 403 Forbidden;
	
	\item \textbf{PatientDashboardFilter}:
	Secures patient dashboard views under \texttt{/user/*}. It checks for an active session with \texttt{role = "patient"} and redirects unauthenticated or improperly privileged users to the login page.
\end{itemize}

\subsection{\texttt{package it.unipi.healthhub.model}}
The \textbf{Model} package defines the entity classes corresponding to the database schema.

The \texttt{it.unipi.healthhub.model.mongo} package contains the core domain entities persisted in MongoDB. These classes represent the primary data models for the application and include:

\begin{itemize}
	\item \textbf{Address.java}: encapsulates patient or doctor address fields (street, city, province, postal code and country);
	\item \textbf{Appointment.java}: models appointment records, linking patients and doctors with date, time and status.;
	\item \textbf{CalendarTemplate.java}: defines named availability templates composed of slot collections;
	\item \textbf{Doctor.java}: represents doctor profiles, including personal details, specializations and business rules;
	\item \textbf{PrenotableSlot.java}: denotes individual time slots available for booking;
	\item \textbf{Review.java}: captures patient‑submitted reviews;
	\item \textbf{Schedule.java}: organizes weekly schedules as mappings from days to prenotable slots;
	\item \textbf{Service.java}: specifies medical services offered by a doctor, including descriptions and pricing;
	\item \textbf{Slot.java}: a simple time interval used within templates and schedules;
	\item \textbf{User.java}: models patient accounts with personal information and secure credentials.
\end{itemize}

In addition, the \texttt{it.unipi.healthhub.model.neo4j} subpackage defines lightweight DAO classes (\textbf{DoctorDAO.java}, \textbf{UserDAO.java}) used exclusively for graph queries. Since all entity attributes required by the application are already captured in the MongoDB models and relationships are managed via Neo4j projections, the MongoDB classes serve as the definitive domain models.

Their structural design has already been detailed in the Design chapter’s UML class diagram section.

\subsection{\texttt{package it.unipi.healthhub.model.mongo}}
\subsubsection{User}
\begin{lstlisting}[language=java]
@Document(collection = "users")
public class User {
	@Id
	protected String id;
	
	protected String username;
	
	protected String name;
	protected String password;
	protected String fiscalCode;
	protected LocalDate dob;
	protected String gender;
	private String personalNumber;
	protected String email;
	
	public String getId() {
		return id;
	}
	public void setId(String id) { this.id = id; }
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getUsername() {
		return username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	
	public String getFiscalCode(){ return fiscalCode; }
	public void setFiscalCode(String fiscalCode){ this.fiscalCode = fiscalCode; }
	
	public String getGender() {
		return gender;
	}
	public void setGender(String gender) {
		this.gender = gender;
	}
	
	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}
	
	public String getPassword() {
		return password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	
	public void setDob(LocalDate dob) {
		this.dob = dob;
	}
	public LocalDate getDob() {
		return dob;
	}
	
	public String getPersonalNumber() {
		return personalNumber;
	}
	
	public void setPersonalNumber(String personalNumber) {
		this.personalNumber = personalNumber;
	}
	
	public String toString() {
		return "User{" +
			", username='" + username + '\'' +
			", password='" + password + '\'' +
			", dob=" + dob + "}";
	}
}
\end{lstlisting}

\subsubsection{}
\begin{lstlisting}[language=java]
	@Document(collection = "doctors")
	public class Doctor extends User {
		protected String orderRegistrationNumber;
		private List<Service> services;
		private int endorsementCount;
		private int reviewCount;
		private List<Review> reviews;
		private List<Schedule> schedules;
		private List<String> calendarTemplates;
		private List<String> specializations;
		private List<String> phoneNumbers;
		private Address address;
		
		public Doctor() {
			super();
			services = new ArrayList<>();
			reviews = new ArrayList<>();
			schedules = new ArrayList<>();
			calendarTemplates = new ArrayList<>();
			specializations = new ArrayList<>();
			phoneNumbers = new ArrayList<>();
		}
		
		public String getOrderRegistrationNumber() { return orderRegistrationNumber; }
		public void setOrderRegistrationNumber(String orderRegistrationNumber) { this.orderRegistrationNumber = orderRegistrationNumber; }
		
		public List<Service> getServices() {
			return services;
		}
		public void setServices(List<Service> services) {
			this.services = services;
		}
		
		public int getEndorsementCount() {
			return endorsementCount;
		}
		public void setEndorsementCount(int endorsementCount) {
			this.endorsementCount = endorsementCount;
		}
		
		public int getReviewCount() {
			return reviewCount;
		}
		public void setReviewCount(int reviewCount) { this.reviewCount = reviewCount; }
		
		public List<Review> getReviews() {
			return reviews;
		}
		public void setReviews(List<Review> reviews) {
			this.reviews = reviews;
		}
		
		public List<Schedule> getSchedules() {
			return schedules;
		}
		public void setSchedules(List<Schedule> schedules) {
			this.schedules = schedules;
		}
		
		public List<String> getCalendarTemplates() {
			return calendarTemplates;
		}
		public void setCalendarTemplates(List<String> calendarTemplates) {
			this.calendarTemplates = calendarTemplates;
		}
		
		public List<String> getSpecializations() {
			return specializations;
		}
		public void setSpecializations(List<String> specializations) {
			this.specializations = specializations;
		}
		
		public List<String> getPhoneNumbers() {
			return phoneNumbers;
		}
		public void setPhoneNumbers(List<String> phoneNumbers) {
			this.phoneNumbers = phoneNumbers;
		}
		
		public Address getAddress() {
			return address;
		}
		public void setAddress(Address address) {
			this.address = address;
		}
		
		public String getId(){
			return super.getId();
		}
		
		public String toString() {
			return "User{" +
				", username='" + getUsername() + '\'' +
				", password='" + getPassword() + '\'' +
				", dob=" + dob + "}";
		}
	}
\end{lstlisting}

\subsubsection{Appointment}
\begin{lstlisting}[language=java]
@Document(collection = "appointments")
public class Appointment {
	@Id
	private String id;
	private LocalDateTime date;
	private DoctorInfo doctor;
	private PatientInfo patient;
	private String visitType;
	private String patientNotes;
	private double price;
	
	// Constructors
	public Appointment() {}
	
	public Appointment(String id, LocalDateTime appointmentDateTime, DoctorInfo doctorInfo, PatientInfo patientInfo, String visitType, String patientNotes) {
		this.id = id;
		this.date = appointmentDateTime;
		this.doctor = doctorInfo;
		this.patient = patientInfo;
		this.visitType = visitType;
		this.patientNotes = patientNotes;
	}
	
	// Getters and Setters
	public String getId() {
		return id;
	}
	
	public void setId(String id) {
		this.id = id;
	}
	
	public LocalDateTime getDate() {
		return date;
	}
	
	public void setDate(LocalDateTime date) {
		this.date = date;
	}
	
	public DoctorInfo getDoctor() {
		return doctor;
	}
	
	public void setDoctor(DoctorInfo doctor) {
		this.doctor = doctor;
	}
	
	public PatientInfo getPatient() {
		return patient;
	}
	
	public void setPatient(PatientInfo patient) {
		this.patient = patient;
	}
	
	public String getVisitType() {
		return visitType;
	}
	
	public void setVisitType(String visitType) {
		this.visitType = visitType;
	}
	
	public String getPatientNotes() {
		return patientNotes;
	}
	
	public void setPatientNotes(String patientNotes) {
		this.patientNotes = patientNotes;
	}
	
	public void setPrice(Double price) {
		this.price = price;
	}
	
	public double getPrice() {
		return price;
	}
	
	// Inner class DoctorInfo
	public static class DoctorInfo {
		private String id;
		private String name;
		private Address address;
		private String email;
		
		public DoctorInfo() {}
		
		public DoctorInfo(String doctorId, String doctorName, Address address, String email) {
			this.id = doctorId;
			this.name = doctorName;
			this.address = address;
			this.email = email;
		}
		
		public String getId() {
			return id;
		}
		
		public void setId(String id) {
			this.id = id;
		}
		
		public String getName() {
			return name;
		}
		
		public void setName(String name) {
			this.name = name;
		}
		
		public Address getAddress() {
			return address;
		}
		
		public void setAddress(Address address) {
			this.address = address;
		}
		
		public String getEmail() {
			return email;
		}
		
		public void setEmail(String email) {
			this.email = email;
		}
	}
	
	// Inner class PatientInfo
	public static class PatientInfo {
		private String id;
		private String name;
		private String email;
		private String gender;
		
		public PatientInfo() {}
		
		public PatientInfo(String patientId, String patientName, String email, String gender) {
			this.id = patientId;
			this.name = patientName;
			this.email = email;
			this.gender = gender;
		}
		
		public String getId() {
			return id;
		}
		
		public void setId(String id) {
			this.id = id;
		}
		
		public String getName() {
			return name;
		}
		
		public void setName(String name) {
			this.name = name;
		}
		
		public String getEmail() {
			return email;
		}
		
		public void setEmail(String email) {
			this.email = email;
		}
		
		public String getGender() {
			return gender;
		}
		
		public void setGender(String gender) {
			this.gender = gender;
		}
	}
}
\end{lstlisting}

\subsubsection{Address}
\begin{lstlisting}[language=java]
public class Address {
	private String street;
	private String city;
	private String province;
	private String postalCode;
	private String country;
	
	// Constructor
	public Address(String street, String city, String province, String postalCode, String country){
		this.street = street;
		this.city = city;
		this.province = province;
		this.postalCode = postalCode;
		this.country = country;
	}
	
	// Getters and Setters
	public String getStreet() {
		return street;
	}
	
	public void setStreet(String street) {
		this.street = street;
	}
	
	public String getCity() {
		return city;
	}
	
	public void setCity(String city) {
		this.city = city;
	}
	
	public String getProvince() {
		return province;
	}
	
	public void setProvince(String province) {
		this.province = province;
	}
	
	public String getPostalCode() {
		return postalCode;
	}
	
	public void setPostalCode(String postalCode) {
		this.postalCode = postalCode;
	}
	
	public String getCountry() {
		return country;
	}
	
	public void setCountry(String country) {
		this.country = country;
	}
	
	public String toString() {
		return street + ", " + city + ", " + province + ", " + postalCode + ", " + country;
	}
	
	public String toShortString() {
		return street + ", " + city;
	}
}
\end{lstlisting}

\subsubsection{Calendar Template}
\begin{lstlisting}[language=java]
	@Document(collection = "templates")
	public class CalendarTemplate {
		@Id
		private String id;
		private String name;
		private Map<String, List<Slot>> slots;
		private boolean isDefault;
		
		// Constructor
		public CalendarTemplate() {}
		
		public CalendarTemplate(String id, String name, Map<String, List<Slot>> slots, boolean isDefault) {
			this.id = id;
			this.name = name;
			this.slots = slots;
			this.isDefault = isDefault;
		}
		
		// Getters and Setters
		public String getId() {
			return id;
		}
		
		public void setId(String id) {
			this.id = id;
		}
		
		public String getName() {
			return name;
		}
		
		public void setName(String name) {
			this.name = name;
		}
		
		public Map<String, List<Slot>> getSlots() {
			return slots;
		}
		
		public void setSlots(Map<String, List<Slot>> slots) {
			this.slots = slots;
		}
		
		public boolean isDefault(){
			return isDefault;
		}
		
		public void setDefault(boolean isDefault) {
			this.isDefault = isDefault;
		}
		
		public String toString() {
			return "CalendarTemplate{" +
				"id='" + id + '\'' +
				", name='" + name + '\'' +
				", slots=" + slots +
				", default=" + isDefault +
				'}';
		}
		
	}
\end{lstlisting}

\subsubsection{Prenotable Slot}
\begin{lstlisting}[language=java]
	public class PrenotableSlot extends Slot{
		private boolean taken;
		
		public PrenotableSlot() {
			super();
		}
		
		public PrenotableSlot(String start, String end, boolean taken) {
			super(start, end);
			this.taken = taken;
		}
		
		public boolean isTaken() {
			return taken;
		}
		
		public void setTaken(boolean taken) {
			this.taken = taken;
		}
	}
\end{lstlisting}

\subsubsection{Review}
\begin{lstlisting}[language=java]
	public class Review {
		public String name;
		public String text;
		public LocalDate date;
		public String patientId;
		
		public String getName() {
			return name;
		}
		public void setName(String name) {
			this.name = name;
		}
		
		public String getText() {
			return text;
		}
		public void setText(String text) {
			this.text = text;
		}
		
		public LocalDate getDate() {
			return date;
		}
		public void setDate(LocalDate date) {
			this.date = date;
		}
		
		public String getPatientId() {
			return patientId;
		}
		public void setPatientId(String patientId) {
			this.patientId = patientId;
		}
	}
\end{lstlisting}

\subsubsection{Schedule}
\begin{lstlisting}[language=java]
	public class Schedule {
		private LocalDate week;
		private Map<String, List<PrenotableSlot>> slots;
		
		// Getters and Setters
		public LocalDate getWeek() {
			return week;
		}
		
		public void setWeek(LocalDate week) {
			this.week = week;
		}
		
		public Map<String, List<PrenotableSlot>> getSlots() {
			return slots;
		}
		
		public void setSlots(Map<String, List<PrenotableSlot>> slots) {
			this.slots = slots;
		}
	}
\end{lstlisting}

\subsubsection{Service}
\begin{lstlisting}[language=java]
	public class Service {
		private String service;
		private double price;
		
		// Constructors
		public Service() {}
		public Service(String service, double price) {
			this.service = service;
			this.price = price;
		}
		
		// Getters and Setters
		public String getService() {
			return service;
		}
		public void setService(String service) {
			this.service = service;
		}
		
		public double getPrice() {
			return price;
		}
		public void setPrice(double price) {
			this.price = price;
		}
	}
\end{lstlisting}

\subsubsection{Slot}
\begin{lstlisting}[language=java]
	public class Slot {
		protected String start;
		protected String end;
		
		// Constructor
		public Slot() {}
		
		public Slot(String start, String end) {
			this.start = start;
			this.end = end;
		}
		
		// Getters and Setters
		public String getStart() {
			return start;
		}
		
		public void setStart(String start) {
			this.start = start;
		}
		
		public String getEnd() {
			return end;
		}
		
		public void setEnd(String end) {
			this.end = end;
		}
		
		public String toString() {
			return "Slot{" +
				"start='" + start + '\'' +
				", end='" + end + '\'' +
				'}';
		}
	}
\end{lstlisting}



\subsection{\texttt{package it.unipi.healthhub.model.neo4j}}

\subsubsection{User DAO}
\begin{lstlisting}[language=java]
	@Node("User")
	public class UserDAO {
		@Id
		private String id;
		private String name;
		
		@Relationship(type = "ENDORSED")
		private Set<DoctorDAO> endorsedDoctors = new HashSet<>();
		
		@Relationship(type = "REVIEWED")
		private Set<DoctorDAO> reviewedDoctors = new HashSet<>();
		
		public UserDAO() {
		}
		
		public UserDAO(String id, String name) {
			this.id = id;
			this.name = name;
		}
		
		public String getId() {
			return id;
		}
		
		public void setId(String id) {
			this.id = id;
		}
		
		public String getName() {
			return name;
		}
		
		public void setName(String name) {
			this.name = name;
		}
		
		public Set<DoctorDAO> getEndorsedDoctors() {
			return endorsedDoctors;
		}
		
		public Set<DoctorDAO> getReviewedDoctors() {
			return reviewedDoctors;
		}
	}
\end{lstlisting}

\subsubsection{Doctor DAO}
\begin{lstlisting}[language=java]
	@Node("Doctor")
	public class DoctorDAO {
		@Id
		private String id;
		
		private String name;
		private List<String> specializations;
		
		public DoctorDAO() {
			specializations = new ArrayList<>();
		}
		
		public DoctorDAO(String id, String name, List<String> specializations) {
			this.id = id;
			this.name = name;
			this.specializations = specializations;
		}
		
		public String getId() {
			return id;
		}
		
		public void setId(String id) {
			this.id = id;
		}
		
		public String getName() {
			return name;
		}
		
		public void setName(String name) {
			this.name = name;
		}
		
		public List<String> getSpecializations() {
			return specializations;
		}
		
		public void setSpecializations(List<String> specializations) {
			this.specializations = specializations;
		}
		
		public String toString() {
			return "DoctorDAO{" +
				"id='" + id + '\'' +
				", name='" + name + '\'' +
				", specializations=" + specializations +
				'}';
		}
	}
\end{lstlisting}

\subsection{\texttt{package it.unipi.healthhub.projection}}
The \texttt{it.unipi.healthhub.projection} package contains projection classes used to encapsulate doctors and their relevance scores obtained from search queries. Specifically, \texttt{DoctorMongoProjection} wraps a MongoDB \texttt{Doctor} entity with a score, while \texttt{DoctorNeo4jProjection} wraps a Neo4j \texttt{DoctorDAO} with a similar score. These projections facilitate merging and ranking results from both databases during doctor search operations, as implemented in the \texttt{SearchAPI} controller.

\subsection{\texttt{package it.unipi.healthhub.repository}}
The \textbf{Repository} package is responsible for managing data access operations by leveraging Spring Data JPA interfaces. This package abstracts the underlying persistence mechanisms, allowing for convenient CRUD operations and custom query definitions on the domain entities. 

Detailed examination and implementation of specific queries within these repositories will be thoroughly discussed in the dedicated chapter on \textit{Queries}. 

\subsection{\texttt{package it.unipi.healthhub.service}}
The \textbf{Service} layer encapsulates the core business logic. This package is composed by: \texttt{AppointmentService}, \texttt{DoctorService} and \texttt{UserService}. 


\subsubsection{Appointment Service}
The \texttt{AppointmentService} class provides a comprehensive set of business logic functionalities related to appointment management within the system. This service interacts directly with the \texttt{AppointmentMongoRepository} to perform CRUD operations on appointment entities stored in MongoDB.

Key aspects of \texttt{AppointmentService} include:
\begin{itemize}
	\item \textbf{Data Sanitization:} To prevent operator injection vulnerabilities specific to MongoDB, the service sanitizes input strings by replacing prohibited characters (e.g., '\$') within appointment fields, including nested doctor and patient information such as names, emailsand addresses.
	
	\item \textbf{CRUD Operations:} The service exposes methods to retrieve all appointments, fetch an appointment by its identifier, create new appointments after sanitization, update existing onesand delete appointments by ID.
	
	\item \textbf{Asynchronous Updates:} Leveraging Spring's \texttt{@Async} annotation, the service asynchronously updates related doctor and patient information within appointments, improving responsiveness and decoupling these potentially costly operations.
	
	\item \textbf{Domain-Specific Queries:} It supports domain-specific queries such as retrieving all appointments for a given doctor on a specified day, facilitating calendar and scheduling functionalities.
\end{itemize}

\subsubsection{Doctor Service}

The \texttt{DoctorService} class manages business logic related to doctor profiles, endorsements, reviews, specializations, analyticsand schedule maintenance. It coordinates between MongoDB (via \texttt{doctorMongoRepository}) for persistent doctor data and Neo4j (via \texttt{doctorNeo4jRepository} and \texttt{userNeo4jRepository}) for relationship data.

Key features of \texttt{DoctorService} include:
\begin{itemize}
	\item \textbf{Data Sanitization:} Prevents injection vulnerabilities by sanitizing input strings differently for MongoDB (e.g., replacing '\$') and Neo4j (e.g., replacing '\$' and '.'). Sanitization applies to doctor fields and nested user data.
	
	\item \textbf{Reviews Management:} Enables patients to add and remove reviews after verifying appointments, updating both doctor documents and Neo4j relationships.
	
	\item \textbf{Profile Updates:} Supports login authentication, updating doctor details such as address, personal infoand phone numbers, with data sanitization and synchronization between MongoDB and Neo4j.
	
	\item \textbf{Specializations Handling:} Allows adding and removing specializations stored in MongoDB and mirrored in Neo4j, returning indices for reference.
	
	\item \textbf{Endorsements:} Manages patient endorsements for doctors by updating counts in MongoDB and maintaining endorsement relationships in Neo4j.
	
	\item \textbf{Analytics:} Provides visit and earnings statistics aggregated by type, week, monthand year, leveraging the appointment repository.
	
	\item \textbf{Schedule Management:} Maintains up-to-date doctor schedules by removing outdated entries and creating new ones for missing weeks, based on default calendar templates. The process includes progress logging and exception handling for missing templates.
	
	\item \textbf{Transactional Consistency:} Critical updates are annotated with \texttt{@Transactional} to ensure atomic operations.
\end{itemize}

\subsubsection{User Service}
The \texttt{UserService} class handles all user-related business logic, managing users stored in both MongoDB and Neo4j databases. It ensures data integrity and synchronization across these stores while supporting user authentication, profile managementand interactions with appointments and doctors.

Key features of \texttt{UserService} include:
\begin{itemize}
	\item \textbf{Data Sanitization:} Prevents injection vulnerabilities by sanitizing input strings differently for MongoDB (e.g., replacing '\$') and Neo4j (e.g., replacing '\$' and '.'). Sanitization applies to user fields and nested doctor data.

	\item \textbf{User CRUD and Authentication:} Provides creation, retrieval, updateand deletion of users with transactional integrity. Includes username/email uniqueness checks and password validation for login and password changes.  
	
	\item \textbf{Profile and Contact Management:} Updates and retrieves detailed user profile information and contact data, synchronizing name changes across appointments and Neo4j relationships.  
	
	\item \textbf{Appointment Integration:} Retrieves past and upcoming appointments for users, supports appointment cancellation with schedule slot management and notification via a fake mail sender.  
	
	\item \textbf{Neo4j Relations and Recommendations:} Manages endorsement and review relations between users and doctors in Neo4j, fetching lists of endorsed, reviewedand recommended doctors. Recommendation logic combines personalized and popular doctors.  
	
	\item \textbf{Email Operations:} Sends password reset links using a mocked mail sender component.  
\end{itemize}

\subsection{\texttt{package it.unipi.healthhub.util}}
This package contains several utility classes and interfaces used within the HealthHub application to support functionalities like session handling, date manipulation, email sending, password hashingand conversion between DTOs and model objects.

\begin{itemize}
	\item \texttt{ControllerUtil.java}\\
	Provides utility methods for controllers, especially for setting common attributes in the Spring \texttt{Model} based on the user session. For example, it adds attributes indicating whether a user is logged in and their role (patient or doctor).
	
	\item \texttt{DateUtil.java}\\
	Contains static methods for date calculations and conversions. Key methods include:
	\begin{itemize}
		\item Getting the first day of a specific week in a year.
		\item Checking if two dates belong to the same week.
		\item Getting the next four Mondays after a given date.
		\item Conversion between \texttt{java.util.Date} and \texttt{java.time.LocalDate}.
	\end{itemize}
	
	\item \texttt{FakeMailSender.java}\\
	A service implementation of the \texttt{MailSenderService} interface that simulates sending emails by printing email content to the console. It handles sending notification emails related to appointment deletions and password reset links, validating email addresses before "sending".
	
	\item \texttt{HashUtil.java}\\
	Provides a method for hashing passwords using SHA-256. It converts the password string into its hashed hexadecimal representation, throwing a runtime exception if hashing fails.
	
	\item \texttt{MailSenderService.java}\\
	An interface defining methods for sending various types of emails related to appointment cancellations and password resets. Implemented by classes such as \texttt{FakeMailSender}.
	
	\item \texttt{ScheduleConverter.java}\\
	Contains static methods to convert schedule data between DTO representations and model objects. It supports transforming collections of slots and building a schedule for a given Monday date based on a calendar template.
	
	\item \texttt{TemplateConverter.java}\\
	Provides static methods for converting template-related slot data between DTOs and model classes, including converting regular slots and "prenotable" (bookable) slots, supporting the workflow of schedule creation and manipulation.
\end{itemize}


\subsection{Scheduler Component}
The \texttt{Scheduler} class is a Spring-managed component responsible for automating weekly maintenance tasks on doctor schedules. Its \texttt{scheduleTask()} method executes every Sunday at midnight, invoking two key \texttt{DoctorService} operations:
\begin{itemize}
	\item \textbf{cleanOldSchedules():} Removes all schedule entries up to the current date, delegating to the repository’s \texttt{cleanOldSchedules(Date)} method to purge obsolete calendar data.
	\item \textbf{setupNewSchedules():} Identifies doctors lacking schedules in the next four weeksand for each missing week constructs new \texttt{Schedule} objects based on their default \texttt{CalendarTemplate}. Progress is logged in intervals to monitor throughput.
\end{itemize}

By centralizing these operations in a scheduled job, the \texttt{Scheduler} ensures that doctor availabilities remain current without manual intervention, leveraging reusable service methods and Spring’s scheduling infrastructure to maintain data consistency and system reliability.

